import{sha256 as l}from"ethers";import{Actions as c,parseStatus as L,chainToId as v}from"@gardenfi/orderbook";import{with0x as u,trim0x as W}from"@catalogfi/utils";const S=async(e,t,r,a)=>{const i=r[e],s=r[t];if(!s)throw new Error(`No ${e} wallet found`);if(!i)throw new Error(`No ${t} wallet found`);let d;if(w(e)){const o=l(u(Buffer.from("catalog.js"+a+await s.getAddress()).toString("hex"))).slice(2);d=await i.sign(o)}else{const o=l(u(Buffer.from("catalog.js"+a+await i.getAddress()).toString("hex"))).slice(2);d=await s.sign(o)}return W(l(u(d)))},w=e=>e==="bitcoin"||e==="bitcoin_testnet"||e==="bitcoin_regtest",m={WALLET_NOT_FOUND:e=>`${e?"from":"to"} wallet not found`,CHAIN_WALLET_NOT_FOUND:e=>`no ${e} wallet found`},p={NO_ACTION:"no actions can be performed in this state",NO_SECRET:"secret not found in order",INVALID_ACTION:(e,t)=>`can not ${e} on status: ${t}`};class ${constructor(t,r){this.order=t,this.wallets=r}get action(){return L(this.order)}get status(){return+`${this.order.status}${this.order.initiatorAtomicSwap.swapStatus}${this.order.followerAtomicSwap.swapStatus}`}async next(){switch(x[this.action]){case"Initiate":return await this.init();case"Redeem":return await this.redeem();case"Refund":return await this.refund();default:return U}}async init(){switch(this.action){case c.UserCanInitiate:{const t=this.wallets[this.order.initiatorAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.initiatorAtomicSwap.chain} wallet found`);return{user:"initiator",action:"Initiate",output:await(await h(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).init()}}case c.CounterpartyCanInitiate:{const t=this.wallets[this.order.followerAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.followerAtomicSwap.chain} wallet`);return{user:"redeemer",action:"Initiate",output:await(await h(t,this.order,"foreign",this.order.followerAtomicSwap.asset)).init()}}default:throw new Error(p.INVALID_ACTION("init",this.status))}}async redeem(){const t=this.getWallet(this.order.followerAtomicSwap.chain),r=this.getWallet(this.order.initiatorAtomicSwap.chain);switch(this.action){case c.UserCanRedeem:{const a=await h(t,this.order,"foreign",this.order.followerAtomicSwap.asset),i=await S(this.order.initiatorAtomicSwap.chain,this.order.followerAtomicSwap.chain,this.wallets,this.order.secretNonce);return console.log("secret when redeeming: ",i),{user:"initiator",action:"Redeem",output:await a.redeem(i,this.order.userBtcWalletAddress)}}case c.CounterpartyCanRedeem:{if(!this.order.secret)throw new Error("Secret not found in order");return{user:"redeemer",action:"Redeem",output:await(await h(r,this.order,"native",this.order.initiatorAtomicSwap.asset)).redeem(this.order.secret)}}default:throw new Error(p.INVALID_ACTION("redeem",this.status))}}async refund(){const t=this.getWallet(this.order.initiatorAtomicSwap.chain),r=this.getWallet(this.order.followerAtomicSwap.chain);if(this.order.initiatorAtomicSwap.swapStatus===3)return{user:"initiator",action:"Refund",output:await(await h(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};if(this.order.followerAtomicSwap.swapStatus===3)return{user:"redeemer",action:"Refund",output:await(await h(r,this.order,"foreign",this.order.followerAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};throw new Error(p.INVALID_ACTION("refund",this.status))}id(){throw new Error("Method not implemented.")}getWallet(t){const r=this.wallets[t];if(!r)throw new Error(`No ${t} wallet found`);return r}}const h=async(e,t,r,a)=>{console.log(r,a);const i=r==="native"?t.initiatorAtomicSwap:t.followerAtomicSwap;return e.newSwap({recipientAddress:i.redeemerAddress,refundAddress:i.initiatorAddress,initiatorAddress:i.initiatorAddress,chain:v[i.chain],expiryBlocks:+i.timelock,secretHash:t.secretHash,amount:+i.amount,contractAddress:a})};var g=(e=>(e.INITIATOR="initiator",e.REDEEMER="redeemer",e))(g||{}),I=(e=>(e.Init="Initiate",e.Redeem="Redeem",e.Refund="Refund",e.None="None",e))(I||{});const x={[c.UserCanInitiate]:"Initiate",[c.CounterpartyCanInitiate]:"Initiate",[c.UserCanRedeem]:"Redeem",[c.CounterpartyCanRedeem]:"Redeem",[c.UserCanRefund]:"Refund",[c.CounterpartyCanRefund]:"Refund",[c.NoAction]:"None"},U={user:"initiator",action:"None",output:""};class D{constructor(t){if(t)this.extensionId=t.id;else if(k())this.extensionId=E("chrome");else if(N())this.extensionId=E("window");else throw new Error("Catalog wallet extension not found")}send(t,r){return new Promise((a,i)=>{const s={url:"",favicon:""},d=window.location.href.split("://")[1].replace(/\/$/,"");s.url=d;let o=document.querySelector("link[rel='icon']");if(o||(o=document.querySelector("link[rel='shortcut icon']")),o||(o=document.querySelector("link[rel='apple-touch-icon']")),o||(o=document.querySelector("meta[property='og:image']")),o)s.favicon=o instanceof HTMLMetaElement?o.content:o.href;else{const n=new URL(window.location.href);s.favicon=`${n.protocol}//${n.hostname}/favicon.ico`}chrome.runtime.sendMessage(this.extensionId,{method:t,params:r,metadata:s},n=>chrome.runtime.lastError?i(chrome.runtime.lastError):typeof n=="object"&&n&&"error"in n?i(n.error):a(n))})}}const N=()=>{try{const e=window;return e&&e.catalog&&e.catalog.id}catch{return!1}},E=e=>{if(e==="chrome")return chrome.runtime.id;if(e==="window")return window.catalog.id;throw new Error("Invalid medium to get wallet id")},k=()=>{try{return chrome&&!!chrome.runtime&&!!chrome.runtime.id}catch{return!1}},O={createOrderAndSwap:"createOrderAndSwap"};class B{constructor(t,r){this.orderbook=t,this.wallets=r}subscribeOrders(t,r){this.orderbook.subscribeOrders(t,r)}unsubscribeOrders(){return this.orderbook.unsubscribeOrders()}async swap(t,r,a,i,s){if(N()){const y=await new D().send(O.createOrderAndSwap,{from:t,to:r,amt:a,receiveAmount:i,opts:s});return Number(y)}const d=this.wallets[t.chain],o=this.wallets[r.chain];if(!d)throw new Error(m.WALLET_NOT_FOUND(!0));if(!o)throw new Error(m.WALLET_NOT_FOUND(!1));H(t.chain,r.chain),(s&&!s.btcInputAddress||!s)&&(s=s||{},s.btcInputAddress=await this.wallets[w(t.chain)?t.chain:r.chain].getAddress());const n=w(t.chain),f=n?o:d,A=n?d:o,R=await f.getAddress(),C=await this.orderbook.getOrders(R),b=n?await A.getAddress():await f.getAddress(),_=n?await f.getAddress():await A.getAddress(),T=await S(t.chain,r.chain,this.wallets,C.length+1);return this.orderbook.createOrder({fromAsset:t,toAsset:r,sendAmount:a.toString(),receiveAmount:i.toString(),receiveAddress:_,sendAddress:b,secretHash:l(u(T)),btcInputAddress:s.btcInputAddress??await A.getAddress()})}getSwap(t){return new $(t,this.wallets)}calculateReceiveAmt(t,r,a){return Promise.resolve(a-a*.03)}}const H=(e,t)=>{if(w(e)===w(t))throw new Error(w(e)?m.CHAIN_WALLET_NOT_FOUND("Bitcoin"):m.CHAIN_WALLET_NOT_FOUND("EVM"))};export{B as GardenJS,I as SwapperActions,g as SwapperRole,O as catalogWalletActions};
