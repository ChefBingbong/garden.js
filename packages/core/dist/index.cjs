"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("ethers"),c=require("@gardenfi/orderbook"),u=require("@catalogfi/utils"),S=async(e,t,r,o)=>{const i=r[e],n=r[t];if(!n)throw new Error(`No ${e} wallet found`);if(!i)throw new Error(`No ${t} wallet found`);let d;if(w(e)){const s=h.sha256(u.with0x(Buffer.from("catalog.js"+o+await n.getAddress()).toString("hex"))).slice(2);d=await i.sign(s)}else{const s=h.sha256(u.with0x(Buffer.from("catalog.js"+o+await i.getAddress()).toString("hex"))).slice(2);d=await n.sign(s)}return u.trim0x(h.sha256(u.with0x(d)))},w=e=>e==="bitcoin"||e==="bitcoin_testnet"||e==="bitcoin_regtest",m={WALLET_NOT_FOUND:e=>`${e?"from":"to"} wallet not found`,CHAIN_WALLET_NOT_FOUND:e=>`no ${e} wallet found`},p={NO_ACTION:"no actions can be performed in this state",NO_SECRET:"secret not found in order",INVALID_ACTION:(e,t)=>`can not ${e} on status: ${t}`};class _{constructor(t,r){this.order=t,this.wallets=r}get action(){return c.parseStatus(this.order)}get status(){return+`${this.order.status}${this.order.initiatorAtomicSwap.swapStatus}${this.order.followerAtomicSwap.swapStatus}`}async next(){switch(v[this.action]){case"Initiate":return await this.init();case"Redeem":return await this.redeem();case"Refund":return await this.refund();default:return L}}async init(){switch(this.action){case c.Actions.UserCanInitiate:{const t=this.wallets[this.order.initiatorAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.initiatorAtomicSwap.chain} wallet found`);return{user:"initiator",action:"Initiate",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).init()}}case c.Actions.CounterpartyCanInitiate:{const t=this.wallets[this.order.followerAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.followerAtomicSwap.chain} wallet`);return{user:"redeemer",action:"Initiate",output:await(await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset)).init()}}default:throw new Error(p.INVALID_ACTION("init",this.status))}}async redeem(){const t=this.getWallet(this.order.followerAtomicSwap.chain),r=this.getWallet(this.order.initiatorAtomicSwap.chain);switch(this.action){case c.Actions.UserCanRedeem:{const o=await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset),i=await S(this.order.initiatorAtomicSwap.chain,this.order.followerAtomicSwap.chain,this.wallets,this.order.secretNonce);return console.log("secret when redeeming: ",i),{user:"initiator",action:"Redeem",output:await o.redeem(i,this.order.userBtcWalletAddress)}}case c.Actions.CounterpartyCanRedeem:{if(!this.order.secret)throw new Error("Secret not found in order");return{user:"redeemer",action:"Redeem",output:await(await l(r,this.order,"native",this.order.initiatorAtomicSwap.asset)).redeem(this.order.secret)}}default:throw new Error(p.INVALID_ACTION("redeem",this.status))}}async refund(){const t=this.getWallet(this.order.initiatorAtomicSwap.chain),r=this.getWallet(this.order.followerAtomicSwap.chain);if(this.order.initiatorAtomicSwap.swapStatus===3)return{user:"initiator",action:"Refund",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};if(this.order.followerAtomicSwap.swapStatus===3)return{user:"redeemer",action:"Refund",output:await(await l(r,this.order,"foreign",this.order.followerAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};throw new Error(p.INVALID_ACTION("refund",this.status))}id(){throw new Error("Method not implemented.")}getWallet(t){const r=this.wallets[t];if(!r)throw new Error(`No ${t} wallet found`);return r}}const l=async(e,t,r,o)=>{console.log(r,o);const i=r==="native"?t.initiatorAtomicSwap:t.followerAtomicSwap;return e.newSwap({recipientAddress:i.redeemerAddress,refundAddress:i.initiatorAddress,initiatorAddress:i.initiatorAddress,chain:c.chainToId[i.chain],expiryBlocks:+i.timelock,secretHash:t.secretHash,amount:+i.amount,contractAddress:o})};var I=(e=>(e.INITIATOR="initiator",e.REDEEMER="redeemer",e))(I||{}),N=(e=>(e.Init="Initiate",e.Redeem="Redeem",e.Refund="Refund",e.None="None",e))(N||{});const v={[c.Actions.UserCanInitiate]:"Initiate",[c.Actions.CounterpartyCanInitiate]:"Initiate",[c.Actions.UserCanRedeem]:"Redeem",[c.Actions.CounterpartyCanRedeem]:"Redeem",[c.Actions.UserCanRefund]:"Refund",[c.Actions.CounterpartyCanRefund]:"Refund",[c.Actions.NoAction]:"None"},L={user:"initiator",action:"None",output:""};class ${constructor(t){if(t)this.extensionId=t.id;else if(x())this.extensionId=g("chrome");else if(E())this.extensionId=g("window");else throw new Error("Catalog wallet extension not found")}send(t,r){return new Promise((o,i)=>{const n={url:"",favicon:""},d=window.location.href.split("://")[1].replace(/\/$/,"");n.url=d;let s=document.querySelector("link[rel='icon']");if(s||(s=document.querySelector("link[rel='shortcut icon']")),s||(s=document.querySelector("link[rel='apple-touch-icon']")),s||(s=document.querySelector("meta[property='og:image']")),s)n.favicon=s instanceof HTMLMetaElement?s.content:s.href;else{const a=new URL(window.location.href);n.favicon=`${a.protocol}//${a.hostname}/favicon.ico`}chrome.runtime.sendMessage(this.extensionId,{method:t,params:r,metadata:n},a=>chrome.runtime.lastError?i(chrome.runtime.lastError):typeof a=="object"&&a&&"error"in a?i(a.error):o(a))})}}const E=()=>{try{const e=window;return e&&e.catalog&&e.catalog.id}catch{return!1}},g=e=>{if(e==="chrome")return chrome.runtime.id;if(e==="window")return window.catalog.id;throw new Error("Invalid medium to get wallet id")},x=()=>{try{return chrome&&!!chrome.runtime&&!!chrome.runtime.id}catch{return!1}},O={createOrderAndSwap:"createOrderAndSwap"};class D{constructor(t,r){this.orderbook=t,this.wallets=r}subscribeOrders(t,r){this.orderbook.subscribeOrders(t,r)}unsubscribeOrders(){return this.orderbook.unsubscribeOrders()}async swap(t,r,o,i,n){if(E()){const T=await new $().send(O.createOrderAndSwap,{from:t,to:r,amt:o,receiveAmount:i,opts:n});return Number(T)}const d=this.wallets[t.chain],s=this.wallets[r.chain];if(!d)throw new Error(m.WALLET_NOT_FOUND(!0));if(!s)throw new Error(m.WALLET_NOT_FOUND(!1));U(t.chain,r.chain),(n&&!n.btcInputAddress||!n)&&(n=n||{},n.btcInputAddress=await this.wallets[w(t.chain)?t.chain:r.chain].getAddress());const a=w(t.chain),A=a?s:d,f=a?d:s,W=await A.getAddress(),b=await this.orderbook.getOrders(W),R=a?await f.getAddress():await A.getAddress(),C=a?await A.getAddress():await f.getAddress(),y=await S(t.chain,r.chain,this.wallets,b.length+1);return this.orderbook.createOrder({fromAsset:t,toAsset:r,sendAmount:o.toString(),receiveAmount:i.toString(),receiveAddress:C,sendAddress:R,secretHash:h.sha256(u.with0x(y)),btcInputAddress:n.btcInputAddress??await f.getAddress()})}getSwap(t){return new _(t,this.wallets)}calculateReceiveAmt(t,r,o){return Promise.resolve(o-o*.03)}}const U=(e,t)=>{if(w(e)===w(t))throw new Error(w(e)?m.CHAIN_WALLET_NOT_FOUND("Bitcoin"):m.CHAIN_WALLET_NOT_FOUND("EVM"))};exports.GardenJS=D;exports.SwapperActions=N;exports.SwapperRole=I;exports.catalogWalletActions=O;
